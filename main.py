# Проєкт: “Менеджер покупок”
# Створити невелику консольну програму, яка допомагає користувачу планувати покупки, рахувати суму, зберігати дані у файл і завантажувати їх при повторному запуску.

# Вітаю у менеджері покупок!
# Меню:
# 1. Додати покупку
# 2. Переглянути список
# 3. Порахувати загальну суму
# 4. Зберегти у файл
# 5. Завантажити з файлу
# 6. Вихід
# Ваш вибір: 1
# Введіть назву товару: Хліб
# Введіть кількість: 2
# Введіть ціну за одиницю: 25
# ✅ Хліб додано до списку!

# ПОЛІДОВНІСТЬ НАПОВНЕННЯ ФАЙЛУ ВІДОБРАЖАЄТЬСЯ РИМСЬКИМИ ЦИФРАМИ

# VII
# функції створюються до того, як буде створена основна програма (тобто спочатку def що потрібно робити - додавати товар, переглянути список, все те, що є у меню); скопіювали та наповнюємо 

def add_item(shopping_list): # додаємо до списку покупок товар; вводиться на екрані цифрою 1; може будет будь-яка кількість, відображено у text2.txt 
    name = input("Enter a name: ") # найменування
    quantity = int(input("Enter a quantity: ")) # кількість
    price = float(input("Enter a price: ")) # ціна


 # VIII створюємо словник, який запамʼятає всі дані. На виході отримуємо словникИ, це будет список словників

    item = { # словник, у яких однакові ключі, але різні значення
        "name": name, # ключ "name" має значення, яке зберігається у змінній "name" (z.B: bread, milk)
        "quantity": quantity, # кількість товару 
        "price": price # ціна
    }

# IX 
    shopping_list.append(item) # додаємо словник до списку покупок

    print(f"✅ {name} is added to list!") # "✅" + "name" is added to list! виводимо на екран; якщо є не лише текст. але й змінні (name),  форматування (f) допомагає

# X
    
def show_list(shopping_list): # продивилися перелік покупок (shopping_list - це список словників, треба щоб вивелося)
    # shopping_list = [{"name": "Bread", "quantity": 2, "price"; 2.0}] => 0-вий елемент, те, що вводимо першим
    # for i in range(len(shopping_list)): # проходимо по індексам (по списку), тобто по довжіні списку; і - це наш словник (найменування, кількість та ціна) і це ЦИФРА
    #     print(f"{i+1}. {shopping_list[i]["name"]} - {shopping_list[i]["quantity"]} x {shopping_list[i]["price"]}€") # 1.пишемо і+1, тому що виводимо на екран; 2.зверниться до словника з 0-вим значенням (і) та до ключа (name), який додатково зазначено у квадратних дужках і поверне Хліб, потім - (тіре) та вказується аналогічно кількість помножена (х) на кількість та евро

# XIII додаємо умови для прінта, бо може бути список порожнім

    if not shopping_list: # запитує - список порожній (додано not)
        print("\nList is empty") # якщо список порожній, то друкує з нового рядку (\n) наступну інформацію List is empty і виконується return
        return # код завершує роботу, виходить із функції і навіть не буде перевірять наступну умову

# якщо список не порожній, то умоване спрацьовує і програма переходить до print("\nYour list: ")

# XII   
    print("\nYour list: ") # додаємо прінт, щоб бачити, що ми отримуємо 

# XI 2 варіант, після закоментованого циклу for i in range()

    for i, item in enumerate(shopping_list, start=1): # 1.потрібні i-індекс та item-набір данних та проходимо по списку покупок, починаючи з першої позиції, перебирає елементи покупки та одночасно отримує їх індекси; 2. start=1 - щоб нумерація не починалась з 0-го індексу задаємо 1 та щоб не друкувати і+1, тобто додає автоматичну нумерацію, починати буде з 1, а не з 0,  (1., 2., ...) 
        # print(i, item)
        print(f"{i}. {item["name"]} - {item["quantity"]} x {item["price"]}€") # звертається до словника (item) = спочатку до найменування, потім до кількості та ціни, тобто не потрібно кожного разу звертатися до shopping_list та видає список у вигляді номер товара, крапочка, найменування товару через тіре кількіть помножена на ціну у евро; замість крапки можна поставити дужку

# XV

def count_total(shopping_list): # розраховує загальну суму покупок
    total = 0 # 1.створюємо додаткову змінну; 2.спочатку загальна сума покупок дорівнює 0, і потім все до неї додається
    for item in shopping_list: # проходимо по кожному елементу списку, але спочатку його треба передати у функцію def count_total() та викликаємо у case
        total += item["quantity"] * item["price"] # звертаємося до ключів та значень словника, що нам потрібно, тобто на даний момент виконано дві умови меню 1 і 2, з яких програма вибирає дані і це кількість і ціна та додаємо до додаткової змінної total
    print(f"Total price: {total:.2f}€") # 1.іде виклик фукнції, а не результату функції; 2.виводить суму з округленням у два символа після коми .2f

# XVI 

def save_to_file(shopping_list): # зберігаємо список до текстового файлу (є два режима w та a)
    # "w" - перезаписує файл, якщо той є або створює новий, якщо немає, тобто стерло файл та записало наново, попереднього файлу немає
    # "a" - дописує (за замовчуванням у кінці файлу) у існуючий файл, якщо файлу немає - помилка, бо а шукає файл, а його немає; не змінив!

    # 1 старий варіант
    # file = open("text2.txt", "w", encoding="utf-8") # відкриття файлу (за замовчуванням считується латиниця, шифрування у подвійних лапках)
    # file.write("Ok") # щось записати
    # file.write("2 line")
    # file.write("new_line")
    # file.close() # закриває файл, після зʼявляється нова вкладка, де є Ok та 2 line

    # 2 новий варіант
    # with open("text2.txt", "w", encoding="utf-8") as f: # з відкритим файлом працюй як f, щойно вийшли - прибрали відступ - файл закрився
    #     f.write("Ok")
    #     f.write("2 line")
    #     f.write("new_line")

    with open("text2.txt", "w", encoding="utf-8") as f: # щоб зберігти файл, спочатку потрібно відкрити, при умові написання українскькою зазначаємо шифрування utf-8, файл не потрібно закривати - робить автоматично ==> вона зчитує режим. Їй треба ім'я файлу, потім режим. Це мінімум два елементи
        for i, item in enumerate(shopping_list, start=1): # зберігаючи файл, знов проходить по списку з першого та до і-того та записує
            # print(i, item)
            f.write(f"{i}. {item["name"]} - {item["quantity"]} x {item["price"]}€\n") # кожний новий товар виводиться з нового рядку за допомогою \n
    print("✅Shopping_list saved to text2.txt") # виводить список покупок у текстовому файлі (окрема вкладка .txt)

def load_from_file(): # повернув список і більше нічого; не передаємо нічого 
    shopping_list = [] # локальна змінна, яка існує лише у ф-ції
    with open("text2.txt", "r", encoding="utf-8") as f: # може зчитувати як рядки, так і через line; відкриває та автоматично закриває, конструкція потребує as f:
        for line in f: # для якоїсь лінії у файлові
            line_list = line.strip()[:-1].split() # звертаюся до лінії line і видаляємо пробіли  до та після рядку за допопмогою strip(), срезом від початку : до -1 прибираємо символ евро € і розділяємо з пробілами на елементи списку split() у файлі text2.txt , де зберігається 1. bread - 2 x 0.98

            # 1 варіант звернення до рядка
            # for i in range(1, len(line_list), 2): # прийтись по кожному елементу, а вони є нечетними, тобто із кроком 2

            # 2 варіант звернення
            name, quantity, price = line_list[1], line_list[3], line_list[5] # 1.залишаємо змінні найменування, кількість та ціна, тобто вони так і запамʼятовуються
            item = { # звертаємося до словника, який вказано(створено) на початку
                "name": name,
                "quantity": int(quantity), # додали int, щоб вказати, що це число
                "price": float(price) # додали float, щоб вказати, що це число з комою
            }
            shopping_list.append(item) # і знову додаємо до shopping_list
    print("✅Load file") #файл завантажено
    return shopping_list # локальна змінна віддасть просто список, який не зберегли (локальна зміна не існує поза межами ф-ції)

                
# I 

def main(): #створюємо def, функція, яка означає, що з чого буде програма взагалі, що вона повинна робити. Коли програма запуститься, вона нас привітає 
    print("Вітаю у менеджері покупок!") # для привітання друкуємо вивід на екран
    shopping_list = [] # 1.є список покупок, це звичайний списочок; на одному відступі від функції, інаше - буде вихід із функції; 2.це порожній список => у Python порожній список ЗАВЖДИ False

# V 

    while True: # використовуємо цикл, щоб кожного разу не вводити через інпут товар; є меню і що саме внести; означає, що while true в main, до якого входить print та choice, бо на одному відступі

# II
        print("----------#-----------") # 1.щоб його видно було, виводимо на екран; 2. "---" - відділили ввід данних від наступного вводу; V.3 прінт у в while
        
        #через три лапки вводимо інформацію, щоб не вводити кожен рядок окремо прінтом (7 принів)= всі рядки мі одинарними лапками сприймаються як рядки
        print(''' 
    Меню: 
    1. Додати покупкок
    2. Переглянути список
    3. Порахувати загальну суму
    4. Зберегти у файл
    5. Завантажити з файлу
    6. Вихід
            ''') # слідкувати за відступами, мають бути один під одним

        try: # перевірка на наявність помилок; спрацьовує, тому що є while True
            choice = int(input("Ваш вибір: "))
        except ValueError: # неправильно ввели число і виявилась помилка
            print("Enter number 1-6!!")
            continue

# IV
            # choice = int(input("Ваш вибір: ")) # робимо вибір продуктів, звичайно вводимо через інпут; далі перебираємо; закоментовано для використання match

# VI         
            # if choice == 1: # на кожному кроці робимо порівняння кожної змінної із певними данними
            #     pass         # щоб щоб не було помилки
            # elif choice == 2:
            #     pass
# при умові використання розгалудження, виконується одна із умов

        match choice: # 1. закоментовано у розгалудженні замінено на match; 2.перевіряємо значення змінної "вибір" 
            case 1: # кожне case це розуміння чому воно повинно дорівнювати
                try: # перевіряє правильність виконання коду для додавання товару 
                    add_item(shopping_list) # викликаємо додавання товару у список (пунк 1 в меню); має співпрацювати із списком, тому у дужки записуємо список; у даному разі тілько викликаємо цункцію, а записано буде пізніше
                # except:
                #   print("Error")
                except Exception as e: # ключове слово помилки: а що там саме трапилось , до чого я звертаюсь
                    print(f"Your error: {e}") # видає помилку у списку (де стоїть список з ключами і значеннями списку)
            case 2:
                show_list(shopping_list) # викликаємо відображення товару у списку (пункт 2 в меню) - передаємо як аргумент shopping_list, а у функції def приймаємо
            case 3:
                count_total(shopping_list) # викликаємо підрахунок товару у списку (пункт 3 в меню) - отримує 
            case 4:
                save_to_file(shopping_list) # викликаємо збережння  список (пункт 4 в меню)
            case 5:
                try:
                    shopping_list = load_from_file() # запамʼятовує ззовні (результат запамаятай до змінної) # викликаємо завантаження списку (пункт 5 в меню)
                except FileNotFoundError:
                    print("File Not Found Error")
            case 6: 
                print("See you!!") # викликаємо вихід із меню
                break # якщо не потрібно перевіряти - додається break; виходить із циклу while True
            case _: # накшталт else = не знайло попереднє, тоді виконай це
                print("Error! Enter number 1-6!") # якщо щось трапилося - виводить помилку

# у match перевіряється кожна із умов, якщо не потрібно перевіряти - додається break; при використання case його завжди потрібнор зупинити, на екран виводить останню дію: case _: # накшталт else = не знайло попереднє, тоді виконай це
              #  print("Error! Enter number 1-6!")

# XIV
                    
if __name__ == "__main__": #якщо імʼя співпадає, то виконай main (якщо відкриваємо програму з іншого файлу, імпортувати щось, то щоб вона не запустилася, а тільки взяти функціонал, який потрібно, то ця перевірка зупинить її, вона не запустить реалізацію) = (коли звертаємося до файлу, він не працює)

# III

    main() # викликаємо функцію def main(), тому що вона названа main

# try:  # перша основна перевірка помилок : перевіряє код, який був запланований
#     "program" #
#     result = "OK" #
# except ValueError:  # якщо ми знаємо конкретну помилку
#     print("ValueError")  # виводимо найменування помилки
#     result = "ValueError"  #
# except ZeroDivisionError:  # ми очикуємо помилку і знаємо їх = помилка ділення на 0
#     print()  # надрукуй на 0 ділити не можна , маємо обробити
#     result = "ZeroDivisionError"  #
# except:  # якщо не знаємо яка буде помилка, та щоб себе убезпечити, просто додаємо except; пишеться в кінці, перевіряє покроково 
#     print("any errors")  # будь-яка помилка
#     result = "any errors"  #
# else:  #
#     result = "else"  #
#     pass  #
# finally:  # виконується завжди! спрацювала помилка чи ні, виконується завджи
#     print(result)  #
#     pass  #

# try -> finally  # якщо код виконаний, передохить до finally
# try -> except -> ... -> except -> finally  # якщо try не спрацював, то виконується except -> ... -> except доти, пока одна зʼіз помилок не спрацює, якщо спрацювала, то виконується finally 
# try -> except -> ... -> except --> else -> finally  # try перевіряє except -> ... і якщо except не спрацював, то потрапляємо в else -> finally

# try -> finally  #
# except -> finally  # except спрацює, коли не знаємо яка помилка та чому викинуло з програми, і це стандартна помилка
# else -> finally   # else - нестандартна помилка 
