# Проєкт: “Менеджер покупок”
# Створити невелику консольну програму, яка допомагає користувачу планувати покупки, рахувати суму, зберігати дані у файл і завантажувати їх при повторному запуску.

# Вітаю у менеджері покупок!
# Меню:
# 1. Додати покупку
# 2. Переглянути список
# 3. Порахувати загальну суму
# 4. Зберегти у файл
# 5. Завантажити з файлу
# 6. Вихід
# Ваш вибір: 1
# Введіть назву товару: Хліб
# Введіть кількість: 2
# Введіть ціну за одиницю: 25
# ✅ Хліб додано до списку!

# ПОЛІДОВНІСТЬ НАПОВНЕННЯ ФАЙЛУ ВІДОБРАЖАЄТЬСЯ РИМСЬКИМИ ЦИФРАМИ

# VII
# функції створюються до того, як буде створена основна програма (тобто спочатку def що потрібно робити - додавати товар, переглянути список, все те, що є у меню); скопіювали та наповнюємо 

def add_item(shopping_list): # додаємо до списку покупок товар; вводиться на екрані цифрою 1; може будет будь-яка кількість, відображено у text2.txt 
    name = input("Enter a name: ") # найменування
    quantity = int(input("Enter a quantity: ")) # кількість
    price = float(input("Enter a price: ")) # ціна


 # VIII створюємо словник, який запамʼятає всі дані. На виході отримуємо словникИ, це будет список словників

    item = { # словник, у яких однакові ключі, але різні значення
        "name": name, # ключ "name" має значення, яке зберігається у змінній "name" (z.B: bread, milk)
        "quantity": quantity, # кількість товару 
        "price": price # ціна
    }

# IX 
    shopping_list.append(item) # додаємо словник до списку покупок

    print(f"✅ {name} is added to list!") # "✅" + "name" is added to list! виводимо на екран; якщо є не лише текст. але й змінні (name),  форматування (f) допомагає

# X
    
def show_list(shopping_list): # продивилися перелік покупок (shopping_list - це список словників, треба щоб вивелося)
    # shopping_list = [{"name": "Bread", "quantity": 2, "price"; 2.0}] => 0-вий елемент, те, що вводимо першим
    # for i in range(len(shopping_list)): # проходимо по індексам (по списку), тобто по довжіні списку; і - це наш словник (найменування, кількість та ціна) і це ЦИФРА
    #     print(f"{i+1}. {shopping_list[i]["name"]} - {shopping_list[i]["quantity"]} x {shopping_list[i]["price"]}€") # 1.пишемо і+1, тому що виводимо на екран; 2.зверниться до словника з 0-вим значенням (і) та до ключа (name), який додатково зазначено у квадратних дужках і поверне Хліб, потім - (тіре) та вказується аналогічно кількість помножена (х) на кількість та евро

    if not shopping_list: # якщо вони відсутні, придбання відсутнє
        print("\nList is empty")
        return
    
    print("\nYour list: ")

# XI 2 варіант, після закоментованого циклу for i in range()

    for i, item in enumerate(shopping_list, start=1): # 1.потрібні i-індекс та item-набір данних; у списку покупок, починаючи з первої позиції перебирає елементи послідовності (покупки) одночасно отримує їх індекси, тобто додає автоматичну нумерацію (1., 2., ...) 
        # print(i, item)
        print(f"{i}. {item["name"]} - {item["quantity"]} x {item["price"]}€") # видає список у вигляді номер товара, крапочка, найменування товару через тіре кількіть помножена на ціну у евро


def count_total(shopping_list): # розраховує загальну суму покупок
    total = 0 # спочатку загальна сума покупок дорівнює 0, і потім все до неї додається 
    for item in shopping_list: # 
        total += item["quantity"] * item["price"]
    print(f"Total price: {total:.2f}€") # виводить суму з округленням у два символа після коми

def save_to_file(shopping_list): # зберігаємо список до текстового файлу 
    # "w" - перезаписує файл, якщо той є або створює новий, якщо немає
    # "a" - дописує (за замовчуванням у кінці файлу) у існуючий файл, якщо файлу немає - помилка, редагує-?
    # file = open("text.txt", "w", encoding="utf-8")
    # file.write("Ok")
    # file.write("2 line")
    # file.write("new_line")
    # file.close()
    # with open("text.txt", "w", encoding="utf-8") as f:
    #     f.write("Ok")
    #     f.write("2 line")
    #     f.write("new_line")
    with open("text.txt", "w", encoding="utf-8") as f: # щоб зберігти файл, спочатку потрібно відкрити, при умові написання українскькою зазначаємо шифрування utf-8, файл не потрібно закривати - робить автоматично ==> вона зчитує режим. Їй треба ім'я файлу, потім режим. Це мінімум два елементи
        for i, item in enumerate(shopping_list, start=1): # зберігаючи файл, знов проходить по списку з першого та до і-того
            # print(i, item)
            f.write(f"{i}. {item["name"]} - {item["quantity"]} x {item["price"]}€\n") # кожний новий товар виводиться з нового рядку за допомогою \n
    print("✅Shopping_list saved to text.txt") # виводить список покупок у текстовому файлі (окрема вкладка .txt)

def load_from_file(): # повернує список і більше нічого
    shopping_list = [] # локальна змінна, яка існує лише у ф-ції
    with open("text2.txt", "r", encoding="utf-8") as f: # відкриває та автоматично закриває, конструкція потрубує as f:
        for line in f: # для кожного рядка
            line_list = line.strip()[:-1].split() # забирає пробіли, розділяє на елементи списку
            # for i in range(1, len(line_list), 2):
            name, quantity, price = line_list[1], line_list[3], line_list[5] # звертаємося до значення 
            item = { # 
                "name": name,
                "quantity": int(quantity),
                "price": float(price)
            }
            shopping_list.append(item) 
    print("✅Load file") #файл завантажено
    return shopping_list # локальна змінна віддасть просто список, який не зберегли (локальна зміна не існує поза межами ф-ції)

                
# I 

def main(): #створюваємо def, функція, яка означає, що з чого буде програма взагалі, що вона повинна робити. Коли програма запуститься, вона нас привітає 
    print("Вітаю у менеджері покупок!") # для привітання друкуємо вивід на екран
    shopping_list = [] # є список покупок, це звичайний списочок; на одному відступі від функції, інаше - буде вихід із функції

# V 

    while True: # використовуємо цикл, щоб кожного разу не вводити через інпут товар; є меню і що саме внести; означає, що while true в main, до якого входить print та choice, бо на одному відступі

# II
        print("----------#-----------") # 1.щоб його видно було, виводимо на екран; 2. "---" - відділили ввід данних від наступного вводу; V.3 прінт у в while
        
        #через три лапки вводимо інформацію, щоб не вводити кожен рядок окремо прінтом (7 принів)= всі рядки мі одинарними лапками сприймаються як рядки
        print(''' 
    Меню: 
    1. Додати покупкок
    2. Переглянути список
    3. Порахувати загальну суму
    4. Зберегти у файл
    5. Завантажити з файлу
    6. Вихід
            ''') # слідкувати за відступами, мають бути один під одним

        try: # перевірка на наявність помилок
            choice = int(input("Ваш вибір: "))
        except ValueError: # неправильно ввели число і виявилась помилка
            print("Enter number 1-6!!")
            continue

# IV
            # choice = int(input("Ваш вибір: ")) # робимо вибір продуктів, звичайно вводимо через інпут; далі перебираємо; закоментовано для використання match

# VI         
            # if choice == 1: # на кожному кроці робимо порівняння кожної змінної із певними данними
            #     pass         # щоб щоб не було помилки
            # elif choice == 2:
            #     pass
# при умові використання розгалудження, виконується одна із умов

        match choice: # 1. закоментовано у розгалудженні замінено на match; 2.перевіряємо значення змінної "вибір" 
            case 1: # кожне case це розуміння чому воно повинно дорівнювати
                try: # перевіряє правильність виконання коду для додавання товару 
                    add_item(shopping_list) # викликаємо додавання товару у список (пунк 1 в меню); має співпрацювати із списком, тому у дужки записуємо список; у даному разі тілько викликаємо цункцію, а записано буде пізніше
                # except:
                #   print("Error")
                except Exception as e: # ключове слово помилки: а що там саме трапилось , до чого я звертаюсь
                    print(f"Your error: {e}") # видає помилку у списку (де стоїть список з ключами і значеннями списку)
            case 2:
                show_list(shopping_list) # викликаємо відображення товару у списку (пункт 2 в меню) - передаємо як аргумент shopping_list, а у функції def приймаємо
            case 3:
                count_total(shopping_list) # викликаємо підрахунок товару у списку (пункт 3 в меню)
            case 4:
                save_to_file(shopping_list) # викликаємо збережння  список (пункт 4 в меню)
            case 5:
                try:
                    shopping_list = load_from_file() # запамʼятовує ззовні (результат запамаятай до змінної) # викликаємо завантаження списку (пункт 5 в меню)
                except FileNotFoundError:
                    print("File Not Found Error")
            case 6: 
                print("See you!!") # викликаємо вихід із меню
                break # якщо не потрібно перевіряти - додається break; виходить із циклу while True
            case _: # накшталт else = не знайло попереднє, тоді виконай це
                print("Error! Enter number 1-6!") # якщо щось трапилося - виводить помилку

# у match перевіряється кожна із умов, якщо не потрібно перевіряти - додається break; при використання case його завжди потрібнор зупинити, на екран виводить останню дію: case _: # накшталт else = не знайло попереднє, тоді виконай це
              #  print("Error! Enter number 1-6!")

                    
if __name__ == "__main__": #якщо імʼя співпадає, то виконай main

# III

    main() # викликаємо функцію def main(), тому що вона названа main

# try:  # перша основна перевірка
#     "program"
#     result = "OK"
# except ValueError:
#     print("ValueError")
#     result = "ValueError"
# except ZeroDivisionError:
#     print()
#     result = "ZeroDivisionError"
# except:
#     print("any errors")
#     result = "any errors"
# else:
#     result = "else"
#     pass
# finally:  # виконується завжди!
#     print(result)
#     pass

# try -> finally
# try -> except -> ... -> except -> finally
# try -> except -> ... -> except --> else -> finally

# try -> finally
# except -> finally
# else -> finally
